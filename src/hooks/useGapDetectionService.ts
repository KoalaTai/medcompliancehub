import { useKV } from '@github/spark/hooks'

interface RegulatoryChange {
  id: string
  regulation: string
  framework: string
  changeType: 'amendment' | 'new_requirement' | 'clarification' | 'deadline_change'
  title: string
  description: string
  effectiveDate: string
  impactLevel: 'critical' | 'high' | 'medium' | 'low'
  confidence: number
  analysisTimestamp: string
  source: string
}

interface ComplianceGap {
  id: string
  type: 'documentation' | 'process' | 'validation' | 'training' | 'system'
  description: string
  regulation: string
  framework: string
  currentState: string
  requiredState: string
  estimatedEffort: string
  priority: 'critical' | 'high' | 'medium' | 'low'
  recommendedActions: string[]
  affectedDocuments: string[]
  complianceRisk: number
  confidence: number
  sourceChangeId: string
  autoGenerated: boolean
  createdAt: string
}

interface GapDetectionSettings {
  enabled: boolean
  scanFrequency: 'hourly' | 'daily' | 'weekly'
  confidenceThreshold: number
  frameworks: string[]
  notificationChannels: ('email' | 'webhook' | 'dashboard')[]
  autoCreateCAPAs: boolean
  includeAllChanges: boolean
  priorityFilter: ('critical' | 'high' | 'medium' | 'low')[]
}

export function useGapDetectionService() {
  const [settings, setSettings] = useKV<GapDetectionSettings>('gap-detection-settings', {
    enabled: true,
    scanFrequency: 'daily',
    confidenceThreshold: 80,
    frameworks: ['FDA 21 CFR 820', 'ISO 13485', 'EU MDR', 'ISO 14971'],
    notificationChannels: ['dashboard', 'email'],
    autoCreateCAPAs: false,
    includeAllChanges: false,
    priorityFilter: ['critical', 'high']
  })

  const [detectedGaps, setDetectedGaps] = useKV<ComplianceGap[]>('detected-gaps', [])
  const [lastScanTime, setLastScanTime] = useKV('last-gap-scan', new Date().toISOString())
  const [scanHistory, setScanHistory] = useKV<any[]>('gap-scan-history', [])

  // Simulate AI-powered gap detection from regulatory changes
  const analyzeRegulatoryChanges = async (changes: RegulatoryChange[]): Promise<ComplianceGap[]> => {
    const gaps: ComplianceGap[] = []
    
    for (const change of changes) {
      if (change.confidence < settings.confidenceThreshold) {
        continue
      }

      // Simulate AI analysis of regulatory change
      const prompt = spark.llmPrompt`
        Analyze this regulatory change and identify potential compliance gaps:
        
        Regulation: ${change.regulation}
        Change: ${change.title}
        Description: ${change.description}
        Impact Level: ${change.impactLevel}
        
        Current compliance frameworks: ${settings.frameworks.join(', ')}
        
        Identify specific gaps in:
        1. Documentation requirements
        2. Process changes needed
        3. Validation activities
        4. Training requirements
        5. System updates
        
        For each gap, provide:
        - Description
        - Current state vs required state
        - Estimated effort
        - Priority level
        - Recommended actions
        - Affected documents
        - Compliance risk percentage
      `

      try {
        const analysis = await spark.llm(prompt, 'gpt-4o', true)
        const analyzedGaps = JSON.parse(analysis)

        // Convert AI analysis to our gap format
        for (const gapData of analyzedGaps.gaps || []) {
          gaps.push({
            id: `gap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            type: gapData.type || 'documentation',
            description: gapData.description,
            regulation: change.regulation,
            framework: change.framework,
            currentState: gapData.currentState || 'Current implementation not documented',
            requiredState: gapData.requiredState || 'New requirements to be implemented',
            estimatedEffort: gapData.estimatedEffort || '8-16 hours',
            priority: gapData.priority || 'medium',
            recommendedActions: gapData.recommendedActions || [],
            affectedDocuments: gapData.affectedDocuments || [],
            complianceRisk: gapData.complianceRisk || 70,
            confidence: gapData.confidence || change.confidence,
            sourceChangeId: change.id,
            autoGenerated: true,
            createdAt: new Date().toISOString()
          })
        }
      } catch (error) {
        console.warn('Failed to analyze regulatory change:', error)
        
        // Fallback: create basic gap from change info
        gaps.push({
          id: `gap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'documentation',
          description: `Review and update compliance for: ${change.title}`,
          regulation: change.regulation,
          framework: change.framework,
          currentState: 'Current compliance status needs review',
          requiredState: change.description,
          estimatedEffort: change.impactLevel === 'critical' ? '24-40 hours' : '8-16 hours',
          priority: change.impactLevel as any,
          recommendedActions: [
            'Review regulatory change requirements',
            'Assess current compliance gaps',
            'Develop implementation plan',
            'Update affected procedures'
          ],
          affectedDocuments: [],
          complianceRisk: change.impactLevel === 'critical' ? 90 : change.impactLevel === 'high' ? 75 : 60,
          confidence: change.confidence,
          sourceChangeId: change.id,
          autoGenerated: true,
          createdAt: new Date().toISOString()
        })
      }
    }

    return gaps
  }

  // Run automated gap detection scan
  const runGapScan = async (regulatoryChanges: RegulatoryChange[] = []) => {
    if (!settings.enabled) {
      throw new Error('Automated gap detection is disabled')
    }

    const scanStartTime = new Date().toISOString()
    
    try {
      // Filter changes based on settings
      const filteredChanges = regulatoryChanges.filter(change => {
        return settings.frameworks.includes(change.regulation) &&
               change.confidence >= settings.confidenceThreshold &&
               (settings.includeAllChanges || settings.priorityFilter.includes(change.impactLevel))
      })

      // Analyze changes for gaps
      const newGaps = await analyzeRegulatoryChanges(filteredChanges)

      // Update detected gaps
      setDetectedGaps(currentGaps => {
        // Remove old auto-generated gaps from same source
        const filteredGaps = currentGaps.filter(gap => 
          !gap.autoGenerated || 
          !filteredChanges.some(change => change.id === gap.sourceChangeId)
        )
        
        return [...filteredGaps, ...newGaps]
      })

      // Update scan history
      const scanResult = {
        timestamp: scanStartTime,
        changesAnalyzed: filteredChanges.length,
        gapsDetected: newGaps.length,
        settings: { ...settings }
      }

      setScanHistory(history => [scanResult, ...history.slice(0, 49)]) // Keep last 50 scans
      setLastScanTime(scanStartTime)

      return {
        success: true,
        gapsDetected: newGaps.length,
        changesAnalyzed: filteredChanges.length,
        timestamp: scanStartTime
      }

    } catch (error) {
      console.error('Gap detection scan failed:', error)
      throw error
    }
  }

  // Create CAPA from gap
  const createCAPAFromGap = async (gap: ComplianceGap) => {
    if (!settings.autoCreateCAPAs) {
      throw new Error('Auto-CAPA creation is disabled')
    }

    // Simulate CAPA creation
    const capaId = `CAPA-${Date.now()}`
    
    return {
      id: capaId,
      title: `Address compliance gap: ${gap.description}`,
      description: gap.description,
      priority: gap.priority,
      estimatedEffort: gap.estimatedEffort,
      actions: gap.recommendedActions,
      affectedDocuments: gap.affectedDocuments,
      dueDate: new Date(Date.now() + (gap.priority === 'critical' ? 7 : 30) * 24 * 60 * 60 * 1000).toISOString(),
      createdFrom: gap.id,
      status: 'pending_review'
    }
  }

  // Dismiss or resolve gap
  const updateGapStatus = (gapId: string, status: 'dismissed' | 'resolved' | 'in_progress') => {
    setDetectedGaps(currentGaps =>
      currentGaps.map(gap =>
        gap.id === gapId
          ? { ...gap, status, updatedAt: new Date().toISOString() }
          : gap
      )
    )
  }

  // Get gap statistics
  const getGapStats = () => {
    const total = detectedGaps.length
    const critical = detectedGaps.filter(gap => gap.priority === 'critical').length
    const high = detectedGaps.filter(gap => gap.priority === 'high').length
    const autoGenerated = detectedGaps.filter(gap => gap.autoGenerated).length
    const averageRisk = detectedGaps.reduce((sum, gap) => sum + gap.complianceRisk, 0) / (total || 1)

    return {
      total,
      critical,
      high,
      autoGenerated,
      averageRisk: Math.round(averageRisk),
      lastScan: lastScanTime
    }
  }

  return {
    settings,
    setSettings,
    detectedGaps,
    runGapScan,
    createCAPAFromGap,
    updateGapStatus,
    getGapStats,
    lastScanTime,
    scanHistory
  }
}